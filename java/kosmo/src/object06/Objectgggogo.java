package object06;
class abc{
	int a ;
	
	public abc();
	
	
	pulbic abc(int a) {
		this.a = a
	}
}
public class Objectgggogo {

	public static void main(String[] args) {
		abc ys = new abc()
				
		
		
		
		
		/* object 객체란 무엇인가
		
		객체는 우리 실생활에서 존재하는 것들을 말한다 
		
		
		
		
		객체는 개별적으로 사용하지만 다른 객체와 관계를 맺으면서도 사용된다 
		관계를 맺는 종류에 따라 
		
		1집합 2사용 3상속관계가 있다. 
		
		자바는 객체 지향 프로그램으로써 특징은 캡슐화 상속 다형성이 있다
		
		캡슐화는 외부로 부터 객체를 보호하여 접근이 어렵게 함으로써 손상을 막을 수 있다
		
		상속은 부모객체가 자식객체에게 필드와 메소드를 물려줌으로써 자식이 부모의 것들을 사용할수 있게 해주는 것이다
		
		다형성은 매개값에 따라서 결과가 달라지는 것들을 뜻한다. 
		
		
		
		객체를 만들기 위해 클래스를 만들게되는데 클래스는 객체를 만들기 위한 일종의 설계도라고 할 수 있다.
		
		
		
		클래스를 생성하는방법
		
		클래스는 하나이상의 문자로 만들어야하며 첫번째 글자에는 숫자가 올수 없다 
		달러, 언더바 외의 특수문자는 사용 불가 자바에서 사용하는문자나 예약어는 사용할수 없다 
		
		
		클래스 내에 클래스 여러개가 들어 갈수있지만 public은 파일이름과 같은 클래스에만 사용할 수 있다. 
		$_
		int String 
		
		
		
		
		객체 생성 
		클래스 이름 변수 = new 클래스 이름() 을 통해 생성하며
		변수는 스택영역에, 만들어진 객체는 힙영역에 저장되며 객체의 주소값을 변수의 스택영역에 저장한다 
		
		
		
		
		
		
		
		
		
		--------------------------------
		클래스의 구성
		
		클래스는 필드 생성자 메소드가 있다
		
		필드는 객체가 가져야할 것들을 저장한다 
		클래스 어느곳이든 생성 할 수있으며 
		생성자나 메소드 내에 생성된 필드는 로컬 변수로 해당 생성자나 메소드 내에서만 사용이 가능하다
		
		
		
		필드를 선언만하고 초기값을 지정하지 않으면 각 타입의 기본 값으로 지정이된다
		
		
		
		객체를 생성한 후 필드에 접근하고자 하면
		클래스이름.필드
		로써 필드에 접근 할 수 있다
		
		
		
		
		생성자는 new와 함께 사용하며 객체의 초기화를 담당한다 
		생성자를 만들지 않을시 기본 생성자가 자동으로 생성된다
		
		객체는 매개값을 달리 하여 여러개의 생성자를 가질 수 있다 
		
		ex
		
		class이름 (){}
		
		class(int a){
		this.a = a}
		
		
		this
		this는 자기 자신이란 뜻으로 객체 내부에서 인스턴스 맴버에 접근하기 위해서 사용한다
		보통 매개값이랑 필드에 있는게 이름이같음으로 구분하는 역할도 한다 
		
		
		
	 	생성자 오버로딩
	 	
	 	생성자 오버로딩 시에는 겹치는 코드가 많아 질수 있기 때문에 
	 	매개값이 적은 생성자를 호출 하여 코드의 
	 	길이를 줄일 수있다. 
		
		
		
		
		메소드 
		메소드는 객체의 동작에 해당하는 중괄호블록
		
		메소드의 구성요소는 선언부(리턴타입, 메소드이름, 매개변수 선언)와 실행블록으로 나뉜다
		public void set()
		public int 
		String 
		{isdfjlkwtj;
		return }
		
		setTable 
		
		리턴값이 없는 경우에는 void를 적고 리턴 값이 있는 경우는 그 타입을 적어준다
		
		매소드이름은 소문자로 작성하지만 중복된단어가 있다면 그 첫글자는 대문자로 작성하여 가독성을 높혀준다 
		또한 숫자로 시작할 수 없고 $와_ 를 제외한 특수문자는 사용할 수 없다.
		메소드 내에서 리턴이 실행되면 그 메소드는 바로 종료된다~~~~~~~~~~~~~~~~~~~~~~~~~
		
		객체내부에서는 그냥 메소드 이름을 적고 매개값이 있는경우 매개값을 넣어주면 된다
		int a 
		
		class.a
		
		class.setTable 
		
		객체 외부에서 메소드 사용법은 필드를 사용하는것과 같다
		객체를 생성후 .을 붙히고 메소드의이름을 적어주면 된다 
		이때 매개값이 존재하는경우 그거에 맞게 매개값을 넣어주면 된다~~~~~~~~~~~~~
		
		static set(int a) {
		return a 
		
		set(10)
		
		
		set(double a)
		return a
		
		set(10.0)
		
		메소드 오버로딩
		생성자 오버로딩과 마찬가지로 같은 이름에 결과값을 달리 나오게 할수 있도록 매소드 오버로딩이있다
		보통 매개값의 타입을 달리하는 경우가 많다 
		중괄호 안에 내용은 같지만 리턴 타입과 매개값의타입이 달라서 다양한 경우에서 동작이 가능하다
		
		
		
		this
		this는 자기 자신이란 뜻으로 ㅈ객체 내부에서 인스턴스 맴버에 접근하기 위해서 사용한다
		보통 매개값이랑 필드에 있는게 이름이같음으로 구분하는 역할도 한다 
		
		
		
		
		
		calss abc = new class();
		
		
		abc.set
		
		
		
		set(int a) {
		return a 
		
		set(10)
		
		
		
		
		
		
		
		
		
		static
		static은 클래스가 메모리로 로딩될때 자동으로 생성된다 
		
		필드와 메소드에 static을 선언 할 수 있는데 static을 선언하면 고정된 멤버로써 
		
		new연산자로 객체를 생성하지 않아도 사용할 수 있게된다
		
		
		보통 변하지 않는 것들을 지정할 때 많이 사용한다
		사용방법은 
		
		(static 으로 선언되있는 것들이 소속된 )클래스이름.정적메소드 혹은 필드
		로 사용한다 
		
		*정적블록내에는 인스턴스 필드나 메소드를 사용할 수없다*
		
		인스턴스 필드나 메소드는 객체가 생성되어야 생성이되지만 사용가능
		static은 객체가 없어도 사용이 되기 때문이다
		
		
		
		
		final
		최종적이란 뜻으로 수정이 불가능 하다는 뜻을 담고 있다
		필드 선언시에 final을 선언하거나 생성자를 선언할때 줄수 있다 
		보통 바뀌면 안되는 것들에 사용한다
		
		
		
		
		static + final
		이름만들어도 뭔가 강력크 해보인다
		절대 변하지 않는 진리라고 보면 되겠다 
		
		선언시에 static final 이라고붙여주고 *대문자를 사용* 해서 선언을 해버린다
		
		
		(defualt) class 
		------------------------------
		접근제한자
		public 클래스 필드 생성자 메소드 
		
		protected 필 생 메 
		
		default 클 필 생 메 
		
		private 필 생 메 
		
		public은 말 그대로 아무나 접근이 가능하다 오픈되어있다
		
		protected는 자식 클래스만 접근이 가능하다
		
		default는 같은 패키지만 접근이 가능합니다 기본적으로 지정을 하지 않으면 모두다 default값을 가집니다
		
		
		private 는 닉값을 합니다 같은 클래스 아무도 접근을 할수 없습니다 
		
		
		
		클래스에 선언 할 수 있는건 public 과 default 두개 뿐입니다~~~~~~~~~
		
		private 로 선언된 필드릐  매개값을 지정하기 위헤 getter setter를 사용한다 
		
		
		

		private int a ;
		
		
		
		
		
		
		
		
		
		
		
		*/
		
		
	}

}
